/* Generated by Together */

package org.flashmonkey.neat.core;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Iterator;

import org.apache.log4j.Logger;
import org.flashmonkey.neat.core.api.IGenome;
import org.flashmonkey.neat.core.api.IInnovation;
import org.flashmonkey.util.RandomUtils;

import util.IOseq;
import util.NeatConstant;

public class Genome implements IGenome {

	private static Logger logger = Logger.getLogger(Genome.class);
	
	/** Is a reference from this genotype to fenotype */
	Network phenotype;

	/** Numeric identification for this genotype */
	private int id;

	/**
	 * Each Gene in (3) has a marker telling when it arose historically; Thus,
	 * these Genes can be used to speciate the population, and the list of Genes
	 * provide an evolutionary history of innovation and link-building
	 */
	ArrayList<Gene> genes;

	/** parameter conglomerations :Reserved parameter space for future use */
	ArrayList<Trait> traits;

	/** Is a collection of NNode mapped in a Vector; */
	ArrayList<NNode> nodes;

	/**
	 * note are two String for store statistics information when genomes are
	 * readed (if exist : null otherwise);
	 */
	public String notes;

	public ArrayList<Gene> getGenes() {
		return genes;
	}

	public void setGenes(ArrayList<Gene> genes) {
		this.genes = genes;
	}

	public ArrayList<Trait> getTraits() {
		return traits;
	}

	public void setTraits(ArrayList<Trait> traits) {
		this.traits = traits;
	}

	public ArrayList<NNode> getNodes() {
		return nodes;
	}

	public void setNodes(ArrayList<NNode> nodes) {
		this.nodes = nodes;
	}

	public Network getPhenotype() {
		return phenotype;
	}

	public void setPhenotype(Network phenotype) {
		this.phenotype = phenotype;
	}
	
	/**
	 * Empty Constructor.
	 */
	public Genome() {
		
	}
	
	/**
	 * Creates a new Genome using the supplied traits, nodes and genes and with the supplied id.
	 * 
	 * @param id
	 * @param traits
	 * @param nodes
	 * @param genes
	 */
	public Genome(int id, ArrayList<Trait> traits, ArrayList<NNode> nodes, ArrayList<Gene> genes) {
		this.id = id;
		this.traits = traits;
		this.nodes = nodes;
		this.genes = genes;
	}

	public Genome duplicate(int new_id) {		
		
		ArrayList<Trait> traits_dup = new ArrayList<Trait>(traits.size());
		ArrayList<NNode> nodes_dup = new ArrayList<NNode>(nodes.size());
		ArrayList<Gene> genes_dup = new ArrayList<Gene>(genes.size());
		
		Trait assoc_trait = null;
		int traitId;

		// Duplicate Traits.
		for (Trait trait : traits) {
			traits_dup.add(new Trait(trait));
		}

		// Duplicate Nodes.
		for (NNode _node : nodes) {
			if (_node.getTrait() != null) {
				traitId = _node.getTrait().getId();
				for (Trait _trait : traits_dup) {
					if (_trait.getId() == traitId) {
						assoc_trait = _trait;
						break;
					}
				}
			}

			NNode newnode = new NNode(_node, assoc_trait);

			_node.dup = newnode;
			nodes_dup.add(newnode);
		}

		// Duplicate Genes.
		for (Gene gene : genes) {
			// point to news nodes created at precedent step
			NNode inode = gene.getLink().getInputNode().dup;
			NNode onode = gene.getLink().getOutputNode().dup;
			Trait traitptr = gene.getLink().getTrait();

			assoc_trait = null;
			if (traitptr != null) {
				traitId = traitptr.getId();
				for (Trait trait : traits) {
					if (trait.getId() == traitId) {
						assoc_trait = trait;
						break;
					}
				}
			}

			// creation of new gene with a pointer to new node
			genes_dup.add(new Gene(gene, assoc_trait, inode, onode));
		}

		// okay all nodes created, the new genome can be generate
		return new Genome(new_id, traits_dup, nodes_dup, genes_dup);
	}


	

	public void mutateLinkWeight(double power, double rate, int mutationType) {

		double num; // counts gene placement
		double gene_total;
		double powermod; // Modified power by gene number

		// The power of mutation will rise farther into the genome
		// on the theory that the older genes are more fit since
		// they have stood the test of time

		double randnum;
		double randchoice; // Decide what kind of mutation to do on a gene
		double endpart; // Signifies the last part of the genome
		double gausspoint;
		double coldgausspoint;

		boolean severe; // Once in a while really shake things up

		// for 50% of Prob. // severe is true

		if (RandomUtils.randomDouble() > 0.5)
			severe = true;
		else
			severe = false;

		num = 0.0;
		gene_total = (double) genes.size();
		endpart = gene_total * 0.8;
		powermod = 1.0;

		for (Gene gene : genes) {

			if (severe) {
				gausspoint = 0.3;
				coldgausspoint = 0.1;
			}

			// with other 50%.....
			else {
				if ((gene_total >= 10.0) && (num > endpart)) {
					gausspoint = 0.5;
					coldgausspoint = 0.3;
				} else {
					if (RandomUtils.randomDouble() > 0.5) {
						gausspoint = 1.0 - rate;
						coldgausspoint = 1.0 - rate - 0.1;
					} else {
						gausspoint = 1.0 - rate;
						coldgausspoint = 1.0 - rate;
					}
				}
			}

			// choise a number from ]-1,+1[
			randnum = RandomUtils.randomBinomial() * RandomUtils.randomBinomial() * power * powermod;

			if (mutationType == NeatConstant.GAUSSIAN) {
				
				randchoice = RandomUtils.randomDouble(); // a number from ]0,1[
				
				if (randchoice > gausspoint) {
					gene.getLink().setWeight(gene.getLink().getWeight() + randnum);
				} else if (randchoice > coldgausspoint) {
					gene.getLink().setWeight(randnum);
				}
			} else if (mutationType == NeatConstant.COLDGAUSSIAN) {
				gene.getLink().setWeight(randnum);
			}
			
			// copy to mutation_num, the current weight
			gene.setMutationNumber(gene.getLink().getWeight());
			num += 1.0;
		}
	}

	/**
	 * Generates a Network (Phenotype) from this Genome (Genotype).
	 * 
	 * @param id
	 * @return
	 */
	public Network genesis(int id) {

		Network newnet = null;
		Trait curtrait = null;
		// Vector nodes_dup = new Vector(1, 0);
		NNode newnode = null;
		ArrayList<NNode> inlist = new ArrayList<NNode>(1);
		ArrayList<NNode> outlist = new ArrayList<NNode>(1);
		ArrayList<NNode> all_list = new ArrayList<NNode>(nodes.size());

		Link curlink = null;
		Link newlink = null;
		NNode inode = null;
		NNode onode = null;
		
		for (NNode _node : nodes) {
			// create a copy of gene node for phenotype.
			newnode = new NNode(_node.type, _node.getId());

			// Derive link's parameters from its Trait.
			curtrait = _node.getTrait();
			newnode.derive_trait(curtrait);
			newnode.inner_level = 0;

			newnode.gen_node_label = _node.gen_node_label;

			// new field
			newnode.is_traversed = false;
			
			if (_node.gen_node_label == NodeLabel.INPUT)
				inlist.add(newnode);
			if (_node.gen_node_label == NodeLabel.BIAS)
				inlist.add(newnode);
			if (_node.gen_node_label == NodeLabel.OUTPUT)
				outlist.add(newnode);

			// add to genotype the pointer to phenotype node
			all_list.add(newnode);
			_node.analogue = newnode;
		}

		if (genes.size() == 0) {
			logger.error("Network has no GENES - results will be unpredictable");
		}

		if (outlist.size() == 0) {
			logger.error("Network has no OUTPUTS - results will be unpredictable");
			logger.debug(toString());
		}

		for (Gene _gene : genes) {
			
			// Only create the link if the gene is enabled
			if (_gene.isEnabled()) {

				curlink = _gene.getLink();

				inode = curlink.getInputNode().analogue;
				onode = curlink.getOutputNode().analogue;
				// NOTE: This line could be run through a recurrency check if desired
				// (no need to in the current implementation of NEAT)
				newlink = new Link(curlink.getWeight(), inode, onode, curlink.isRecurrent());
				onode.incoming.add(newlink);
				inode.outgoing.add(newlink);

				// Derive link's parameters from its Trait.
				curtrait = curlink.getTrait();
				curlink.deriveTrait(curtrait);
			}

		}
		
		// Create the new network
		newnet = new Network(inlist, outlist, all_list, id);
		// Attach genotype and phenotype together:
		// newnet point to owner genotype (this)
		newnet.setGenotype(this);
		// genotype point to owner phenotype (newnet)

		phenotype = newnet;
		
		return newnet;
	}

	/**
	 * This function gives a measure of compatibility between two Genomes by
	 * computing a linear combination of 3 characterizing variables of their
	 * compatibilty. The 3 variables represent PERCENT DISJOINT GENES, PERCENT
	 * EXCESS GENES, MUTATIONAL DIFFERENCE WITHIN MATCHING GENES. So the formula
	 * for compatibility is:
	 * disjoint_coeff*pdg+excess_coeff*peg+mutdiff_coeff*mdmg. The 3
	 * coefficients are global system parameters
	 */
	public double compatibility(Genome g) {

		// Innovation numbers
		double p1innov;
		double p2innov;

		// Intermediate value
		double mut_diff;

		// Set up the counters
		double num_disjoint = 0.0;
		double num_excess = 0.0;
		double mut_diff_total = 0.0;
		double num_matching = 0.0; // Used to normalize mutation_num differences

		Gene _gene1 = null;
		Gene _gene2 = null;

		double max_genome_size; // Size of larger Genome

		// Get the length of the longest Genome for percentage computations
		int size1 = genes.size();
		int size2 = g.genes.size();
		max_genome_size = Math.max(size1, size2);
		// Now move through the Genes of each potential parent
		// until both Genomes end
		int j = 0;
		int j1 = 0;
		int j2 = 0;

		for (j = 0; j < max_genome_size; j++) {

			if (j1 >= size1) {
				num_excess += 1.0;
				j2++;
			} else if (j2 >= size2) {
				num_excess += 1.0;
				j1++;
			} else {
				_gene1 = (Gene) genes.get(j1);
				_gene2 = (Gene) g.genes.get(j2);

				// Extract current innovation numbers
				p1innov = _gene1.getInnovationNumber();
				p2innov = _gene2.getInnovationNumber();

				if (p1innov == p2innov) {
					num_matching += 1.0;
					mut_diff = Math.abs(_gene1.getMutationNumber()
							- _gene2.getMutationNumber());
					mut_diff_total += mut_diff;
					j1++;
					j2++;
				} else if (p1innov < p2innov) {
					j1++;
					num_disjoint += 1.0;
				} else if (p2innov < p1innov) {
					j2++;
					num_disjoint += 1.0;
				}

			}

		}

		// Return the compatibility number using compatibility formula
		// Note that mut_diff_total/num_matching gives the AVERAGE
		// difference between mutation_nums for any two matching Genes
		// in the Genome.
		// Look at disjointedness and excess in the absolute (ignoring size)

		return (Neat.disjoint_coeff * (num_disjoint / 1.0)
				+ Neat.disjoint_coeff * (num_excess / 1.0) + Neat.mutdiff_coeff
				* (mut_diff_total / num_matching));

	}

	public double get_last_gene_innovnum() {
		return (((Gene) genes.get(genes.size() - 1)).getInnovationNumber() + 1);
	}

	public int get_last_node_id() {
		return (((NNode) nodes.get(genes.size() - 1)).getId() + 1);
	}

	

	public boolean verify() {

		NNode inputNode = null;
		NNode outputNode = null;
		int i1 = 0;
		int o1 = 0;
		boolean r1 = false;
		boolean disab = false;
		int last_id = 0;

		if (genes.size() == 0) {
			logger.error("Problem creating random Genome - There are no Genes!");
			return false;
		}

		if (nodes.size() == 0) {
			logger.error("Problem creating random Genome - There are no Nodes!");
			return false;
		}

		if (traits.size() == 0) {
			logger.error("Problem creating random Genome - There are no Traits!");
			return false;
		}

		// control if nodes in gene are defined and are the same nodes il nodes list
		for (Gene gene : genes) {

			inputNode = gene.getLink().getInputNode();
			outputNode = gene.getLink().getOutputNode();

			if (inputNode == null) {
				logger.error("input node is null in genome #" + getId());
				return false;
			}
			if (outputNode == null) {
				logger.error("output node is null in genome #" + getId());
				return false;
			}
			if (!nodes.contains(inputNode)) {
				logger.error("Missing Input Node (" + inputNode.getId() + ") - node defined in gene not found in Vector nodes of genome #" + getId());
				return false;
			}
			if (!nodes.contains(outputNode)) {
				logger.error("Missing Output Node (" + outputNode.getId() + ") - node defined in gene not found in Vector nodes of genome #" + getId());
				return false;
			}
		}

		for (NNode node : nodes) {
			if (node.getId() < last_id) {
				System.out.println("ALERT: NODES OUT OF ORDER : ");
				System.out.println(" last node_id is= " + last_id + " , current node_id=" + node.getId());
				return false;
			}
			last_id = node.getId();
		}

		// control in genes are gene duplicate for contents
		for (Gene gene : genes) {
			i1 = gene.getLink().getInputNode().getId();
			o1 = gene.getLink().getOutputNode().getId();
			r1 = gene.getLink().isRecurrent();

			for (Gene gene1 : genes) {
				if (gene1.getLink().getInputNode().getId() == i1
						&& gene1.getLink().getOutputNode().getId() == o1
						&& gene1.getLink().isRecurrent() == r1) {
					
					logger.error("DUPLICATE GENES! :");
					logger.error("input node = " + i1 + " output node = " + o1);
					logger.error("in GENOME id --> " + getId());
					logger.error("gene1 is : \n" + gene.toString());
					logger.error("gene2 is : " + gene1.toString());

					return false;
				}

			}

		}

		if (nodes.size() >= 500) {
			disab = false;
			for (Gene gene : genes) {
				if (!gene.isEnabled() && disab) {
					logger.error("2 DISABLES IN A ROW! : " + gene.getLink().getInputNode().getId());
					logger.error("input node = " + gene.getLink().getInputNode().getId());
					logger.error("output node = " + gene.getLink().getOutputNode().getId());
					logger.error("for GENOME " + getId());
					logger.error("Gene is : " + gene.toString());
				}
				
				disab = !gene.isEnabled();
			}
		}

		return true;
	}

	public void print_to_filename(String xNameFile) {
		//
		// write to file genome in native format (for re-read)
		//
		IOseq xFile;

		xFile = new IOseq(xNameFile);
		xFile.IOseqOpenW(false);

		try {

			print_to_file(xFile);

		} catch (Throwable e) {
			System.err.println(e);
		}

		xFile.IOseqCloseW();

	}

	public Genome mateMultipoint(Genome g, int id, double fitness1, double fitness2) {

		Genome new_genome = null;
		boolean disable = false; // Set to true if we want to disabled a chosen
									// gene
		boolean done = false;
		boolean done_in = false;
		boolean done_out = false;

		// int h = 0;
		int traitnum = 0;
		int nodetraitnum = 0;
		int len = 0;

		Gene _curgene2 = null;
		Gene newgene = null;
		NNode inode = null;
		NNode onode = null;
		NNode new_inode = null;
		NNode new_onode = null;
		NNode curnode = null;

		Gene chosengene = null;
		Gene _p1gene = null;
		Gene _p2gene = null;
		Trait newtrait = null;
		Trait _trait1 = null;
		Trait _trait2 = null;
		double p1innov = 0;
		double p2innov = 0;

		int j;
		int j1;
		int j2;

		// Tells if the first genome (this one) has better fitness or not
		boolean skip = false;

		// First, average the Traits from the 2 parents to form the baby's
		// Traits
		// It is assumed that trait vectors are the same length
		// In the future, may decide on a different method for
		// trait mating (corrispondenza)

		int len_traits = traits.size();

		ArrayList<Trait> newtraits = new ArrayList<Trait>(len_traits);

		for (j = 0; j < len_traits; j++) {
			_trait1 = (Trait) traits.get(j);
			_trait2 = (Trait) g.traits.get(j);
			newtrait = new Trait(_trait1, _trait2);
			newtraits.add(newtrait);

		}

		// Figure out which genome is better
		// The worse genome should not be allowed to add extra structural
		// baggage
		// If they are the same, use the smaller one's disjoint and excess genes
		// only

		boolean p1better = false;

		int size1 = genes.size();
		int size2 = g.genes.size();

		if (fitness1 > fitness2)
			p1better = true;

		else if (fitness1 == fitness2) {
			if (size1 < size2)
				p1better = true;
		}

		int len_genome = Math.max(size1, size2);
		int len_nodes = nodes.size();

		ArrayList<Gene> newgenes = new ArrayList<Gene>(len_genome);
		ArrayList<NNode> newnodes = new ArrayList<NNode>(len_nodes);

		Iterator itr_newgenes;

		j1 = 0;
		j2 = 0;

		int control_disable = 0;
		int exist_disable = 0;

		while (j1 < size1 || j2 < size2) {
			//
			// chosen of 'just' gene
			//	

			skip = false; // Default to not skipping a chosen gene
			if (j1 >= size1) {
				chosengene = (Gene) g.genes.get(j2);
				j2++;
				if (p1better)
					skip = true; // Skip excess from the worse genome
			} else if (j2 >= size2) {
				chosengene = (Gene) genes.get(j1);
				j1++;
				if (!p1better)
					skip = true; // Skip excess from the worse genome
			} else {

				_p1gene = (Gene) genes.get(j1);
				_p2gene = (Gene) g.genes.get(j2);

				p1innov = _p1gene.getInnovationNumber();
				p2innov = _p2gene.getInnovationNumber();
				if (p1innov == p2innov) {
					if (RandomUtils.randomDouble() < 0.5)
						chosengene = _p1gene;
					else
						chosengene = _p2gene;

					// If one is disabled, the corresponding gene in the
					// offspring
					// will likely be disabled
					disable = false;
					if ((_p1gene.isEnabled() == false)
							|| (_p2gene.isEnabled() == false)) {
						exist_disable++;
						if (RandomUtils.randomDouble() < 0.75) {
							disable = true;
							control_disable++;
						}
					}
					j1++;
					j2++;

				} else if (p1innov < p2innov) {
					chosengene = _p1gene;
					j1++;
					if (!p1better)
						skip = true;
				} else if (p2innov < p1innov) {
					chosengene = _p2gene;
					j2++;
					if (p1better)
						skip = true;
				}
			}// end chosen gene

			//
			//
			// Check to see if the chosengene conflicts with an already chosen
			// gene
			// i.e. do they represent the same link
			//

			itr_newgenes = newgenes.iterator();

			while (itr_newgenes.hasNext()) {
				_curgene2 = ((Gene) itr_newgenes.next());

				if (_curgene2.getLink().getInputNode().getId() == chosengene.getLink().getInputNode()
						.getId()
						&& _curgene2.getLink().getOutputNode().getId() == chosengene
								.getLink().getOutputNode().getId()
						&& _curgene2.getLink().isRecurrent() == chosengene
								.getLink().isRecurrent()) {
					skip = true;
					break;
				}
				if (_curgene2.getLink().getInputNode().getId() == chosengene.getLink().getOutputNode()
						.getId()
						&& _curgene2.getLink().getOutputNode().getId() == chosengene
								.getLink().getInputNode().getId()
						&& !_curgene2.getLink().isRecurrent()
						&& !chosengene.getLink().isRecurrent()) {
					skip = true;
					break;
				}

			}

			//
			// 
			//
			if (!skip) {
				// Now add the chosengene to the baby
				// First, get the trait pointer
				int first_traitnum = ((Trait) traits.get(0)).getId();

				if (chosengene.getLink().getTrait() == null)
					traitnum = first_traitnum;
				else
					traitnum = chosengene.getLink().getTrait().getId()
							- first_traitnum;

				// Next check for the nodes, add them if not in the baby Genome
				// already
				inode = chosengene.getLink().getInputNode();
				onode = chosengene.getLink().getOutputNode();

				// Check for inode in the newnodes list

				//
				// Check for inode, onode in the newnodes list
				//

				// --------------------------------------------------------------------------------
				boolean found;
				if (inode.getId() < onode.getId()) {
					//
					// search the inode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == inode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_inode = curnode;

					// else create the inode
					else {
						if (inode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = inode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_inode = new NNode(inode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_inode);
					}

					//
					// search the onode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == onode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_onode = curnode;

					// else create the onode
					else {
						if (onode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = onode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_onode = new NNode(onode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_onode);
					}

				} // end block : inode.node_id < onode.node_id

				else {

					//
					// search the onode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == onode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_onode = curnode;

					// else create the onode
					else {
						if (onode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = onode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_onode = new NNode(onode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_onode);
					}

					//
					// search the inode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == inode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_inode = curnode;

					// else create the inode
					else {
						if (inode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = inode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_inode = new NNode(inode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_inode);
					}

				}

				// --------------------------------------------------------------------------------

				// Add the Gene
				newtrait = (Trait) newtraits.get(traitnum);
				newgene = new Gene(chosengene, newtrait, new_inode, new_onode);
				if (disable) {
					newgene.setEnabled(false);
					disable = false;
				}
				newgenes.add(newgene);
			}

		} // end block genome (while)

		new_genome = new Genome(id, newtraits, newnodes, newgenes);

		// ----------------------------------------------------------------------------------------

		// boolean h = new_genome.verify();
		boolean found = false;
		for (int ix = 0; ix < newnodes.size(); ix++) {
			curnode = (NNode) newnodes.get(ix);
			if (curnode.gen_node_label == NodeLabel.OUTPUT) {
				found = true;
				break;
			}
		}

		if (!found) {
			System.out .print("\n *--------------- not found output node ----------------------------");
			System.out .print("\n * during mate_multipoint : please control the following's *********");
			System.out.print("\n * control block : ");
			System.out.print("\n Genome A = " + toString());
			System.out.print("\n Genome B = " + g.toString());
			System.out.print("\n Result = " + new_genome.toString());

			System.exit(0);
		}
		// ----------------------------------------------------------------------------------------

		return new_genome;
	}

	public Genome mateMultipointAverage(Genome g, int id, double fitness1, double fitness2) {

		Genome new_genome = null;
		boolean disable = false; // Set to true if we want to disabled a chosen
									// gene
		boolean done = false;
		boolean done_in = false;
		boolean done_out = false;
		int traitnum = 0;
		int nodetraitnum = 0;
		int len = 0;

		int control_disable = 0;
		int exist_disable = 0;

		Gene chosengene = null;
		Gene _curgene2 = null;
		Gene newgene = null;
		NNode inode = null;
		NNode onode = null;
		NNode new_inode = null;
		NNode new_onode = null;
		NNode curnode = null;

		Gene _p1gene = null;
		Gene _p2gene = null;
		Trait newtrait = null;
		Trait _trait1 = null;
		Trait _trait2 = null;
		double p1innov = 0;
		double p2innov = 0;

		int j;
		int j1;
		int j2;
		boolean skip = false;

		// Set up the avgene
		Gene avgene = new Gene((Trait) null, 0.0, (NNode) null, (NNode) null,
				false, 0.0, 0.0);
		// First, average the Traits from the 2 parents to form the baby's
		// Traits
		// It is assumed that trait vectors are the same length
		// In the future, may decide on a different method for
		// trait mating (corrispondenza)
		int len_traits = traits.size();

		ArrayList<Trait> newtraits = new ArrayList<Trait>(len_traits);
		for (j = 0; j < len_traits; j++) {
			_trait1 = (Trait) traits.get(j);
			_trait2 = (Trait) g.traits.get(j);
			newtrait = new Trait(_trait1, _trait2);
			newtraits.add(newtrait);

		}

		// Figure out which genome is better
		// The worse genome should not be allowed to add extra structural
		// baggage
		// If they are the same, use the smaller one's disjoint and excess genes
		// only

		boolean p1better = false;
		int size1 = genes.size();
		int size2 = g.genes.size();

		if (fitness1 > fitness2)
			p1better = true;
		else if (fitness1 == fitness2) {
			if (size1 < size2)
				p1better = true;
		}
		int len_genome = Math.max(size1, size2);
		int len_nodes = nodes.size();

		ArrayList<Gene> newgenes = new ArrayList<Gene>(len_genome);
		ArrayList<NNode> newnodes = new ArrayList<NNode>(len_nodes);

		Iterator itr_newgenes;

		j1 = 0;
		j2 = 0;

		while (j1 < size1 || j2 < size2)

		// while (newgenes.size() < len_genome)

		{
			//
			// chosen of 'just' gene
			//
			avgene.setEnabled(true); // Default to enabled
			skip = false; // Default to not skipping a chosen gene

			if (j1 >= size1) {
				chosengene = (Gene) g.genes.get(j2);
				j2++;
				if (p1better)
					skip = true; // Skip excess from the worse genome
			} else if (j2 >= size2) {
				chosengene = (Gene) genes.get(j1);
				j1++;
				if (!p1better)
					skip = true; // Skip excess from the worse genome
			} else {

				_p1gene = (Gene) genes.get(j1);
				_p2gene = (Gene) g.genes.get(j2);
				p1innov = _p1gene.getInnovationNumber();
				p2innov = _p2gene.getInnovationNumber();
				if (p1innov == p2innov) {

					if (RandomUtils.randomDouble() > 0.5)
						avgene.getLink().setTrait(_p1gene.getLink().getTrait());
					else
						avgene.getLink().setTrait(_p2gene.getLink().getTrait());

					// WEIGHTS AVERAGED HERE
					avgene.getLink().setWeight((_p1gene.getLink().getWeight() + _p2gene
							.getLink().getWeight()) / 2.0);

					if (RandomUtils.randomDouble() > 0.5)
						avgene.getLink().setInputNode(_p1gene.getLink().getInputNode());
					else
						avgene.getLink().setInputNode(_p2gene.getLink().getInputNode());

					if (RandomUtils.randomDouble() > 0.5)
						avgene.getLink().setOutputNode(_p1gene.getLink().getOutputNode());
					else
						avgene.getLink().setOutputNode(_p2gene.getLink().getOutputNode());

					if (RandomUtils.randomDouble() > 0.5)
						avgene.getLink().setRecurrent(_p1gene.getLink().isRecurrent());
					else
						avgene.getLink().setRecurrent(_p2gene.getLink().isRecurrent());

					avgene.setInnovationNumber(_p1gene.getInnovationNumber());
					avgene.setMutationNumber(_p1gene.getMutationNumber()
							+ _p2gene.getMutationNumber() / 2.0);

					// If one is disabled, the corresponding gene in the
					// offspring
					// will likely be disabled
					disable = false;
					if ((_p1gene.isEnabled() == false)
							|| (_p2gene.isEnabled() == false)) {
						exist_disable++;

						if (RandomUtils.randomDouble() < 0.75) {
							disable = true;
							control_disable++;
						}
					}

					chosengene = avgene;

					j1++;
					j2++;

				} else if (p1innov < p2innov) {
					chosengene = _p1gene;
					j1++;
					if (!p1better)
						skip = true;
				} else if (p2innov < p1innov) {
					chosengene = _p2gene;
					j2++;
					if (p1better)
						skip = true;
				}
			} // end chosen gene

			//
			//
			// Check to see if the chosengene conflicts with an already chosen
			// gene
			// i.e. do they represent the same link
			//

			itr_newgenes = newgenes.iterator();

			while (itr_newgenes.hasNext()) {
				_curgene2 = ((Gene) itr_newgenes.next());

				if (_curgene2.getLink().getInputNode().getId() == chosengene.getLink().getInputNode()
						.getId()
						&& _curgene2.getLink().getOutputNode().getId() == chosengene
								.getLink().getOutputNode().getId()
						&& _curgene2.getLink().isRecurrent() == chosengene
								.getLink().isRecurrent()) {
					skip = true;
					break;
				}
				if (_curgene2.getLink().getInputNode().getId() == chosengene.getLink().getOutputNode()
						.getId()
						&& _curgene2.getLink().getOutputNode().getId() == chosengene
								.getLink().getInputNode().getId()
						&& !_curgene2.getLink().isRecurrent()
						&& !chosengene.getLink().isRecurrent()) {
					skip = true;
					break;
				}

			}

			//
			// 
			//

			if (!skip) {
				// Now add the chosengene to the baby
				// First, get the trait pointer
				int first_traitnum = ((Trait) traits.get(0)).getId();

				if (chosengene.getLink().getTrait() == null)
					traitnum = first_traitnum;
				else
					traitnum = chosengene.getLink().getTrait().getId()
							- first_traitnum;

				// Next check for the nodes, add them if not in the baby Genome
				// already
				inode = chosengene.getLink().getInputNode();
				onode = chosengene.getLink().getOutputNode();

				// Check for inode in the newnodes list
				//

				// --------------------------------------------------------------------------------
				boolean found;
				if (inode.getId() < onode.getId()) {
					//
					// search the inode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == inode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_inode = curnode;

					// else create the inode
					else {
						if (inode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = inode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_inode = new NNode(inode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_inode);
					}

					//
					// search the onode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == onode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_onode = curnode;

					// else create the onode
					else {
						if (onode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = onode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_onode = new NNode(onode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_onode);
					}

				} // end block : inode.node_id < onode.node_id

				else {

					//
					// search the onode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == onode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_onode = curnode;

					// else create the onode
					else {
						if (onode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = onode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_onode = new NNode(onode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_onode);
					}

					//
					// search the inode
					// 
					found = false;
					for (int ix = 0; ix < newnodes.size(); ix++) {
						curnode = (NNode) newnodes.get(ix);
						if (curnode.getId() == inode.getId()) {
							found = true;
							break;
						}

					}

					// if exist , point to exitsting version
					if (found)
						new_inode = curnode;

					// else create the inode
					else {
						if (inode.getTrait() == null)
							nodetraitnum = 0;
						else
							nodetraitnum = inode.getTrait().getId()
									- first_traitnum;

						newtrait = (Trait) newtraits.get(nodetraitnum);
						new_inode = new NNode(inode, newtrait);
						// insert in newnodes list
						nodeInsert(newnodes, new_inode);
					}

				}

				// --------------------------------------------------------------------------------

				// Add the Gene
				newtrait = (Trait) newtraits.get(traitnum);
				newgene = new Gene(chosengene, newtrait, new_inode, new_onode);
				if (disable) {
					newgene.setEnabled(false);
					disable = false;
				}
				newgenes.add(newgene);

			}

		} // end block genome

		new_genome = new Genome(id, newtraits, newnodes, newgenes);

		return new_genome;
	}

	/**
   * 
   *
   *
   *
   *
   */
	public Genome mateSinglepoint(Genome spouse, int id) {
		String mask4 = " 0000";
		DecimalFormat fmt4 = new DecimalFormat(mask4);
		Genome new_genome = null;
		Gene chosengene = null;
		Trait _trait1 = null;
		Trait _trait2 = null;
		Trait newtrait = null;
		int stopA = 0;
		int stopB = 0;
		int j;
		int j1;
		int j2;
		int control_addnode = 0;
		int len_traits = traits.size();
		int size1 = genes.size();
		int size2 = spouse.genes.size();
		int crosspoint = 0;
		int len_genome = 0;
		int len = 0;

		double p1innov = 0.0;
		double p2innov = 0.0;

		Iterator itr_newgenes;

		NNode curnode = null;
		NNode inode = null;
		NNode onode = null;
		NNode new_inode = null;
		NNode new_onode = null;
		Gene newgene = null;
		boolean disable = false;

		int traitnum = 0;
		int nodetraitnum = 0;

		ArrayList<Gene> genomeA;
		ArrayList<Gene> genomeB;
		Gene geneA = null;
		Gene geneB = null;
		Gene _curgene2 = null;
		int genecounter = 0; // Ready to count to crosspoint
		boolean skip = false; // Default to not skip a Gene
		boolean done_in = false;
		boolean done_out = false;

		ArrayList<Trait> newtraits = new ArrayList<Trait>(len_traits);

		for (j = 0; j < len_traits; j++) {
			_trait1 = (Trait) traits.get(j);
			_trait2 = (Trait) spouse.traits.get(j);
			newtrait = new Trait(_trait1, _trait2);
			newtraits.add(newtrait);

		}

		// Set up the avgene
		Gene avgene = new Gene((Trait) null, 0.0, (NNode) null, (NNode) null,
				false, 0.0, 0.0);

		ArrayList<Gene> newgenes = new ArrayList<Gene>(genes.size());
		ArrayList<NNode> newnodes = new ArrayList<NNode>(nodes.size());

		if (size1 < size2) {
			crosspoint = RandomUtils.randomInt(0, size1 - 1);
			stopA = size1;
			stopB = size2;
			len_genome = size2;
			genomeA = genes;
			genomeB = spouse.genes;
		} else {
			crosspoint = RandomUtils.randomInt(0, size2 - 1);
			stopA = size2;
			stopB = size1;
			len_genome = size1;
			genomeA = spouse.genes;
			genomeB = genes;
		}

		// System.out.print("\n crossing point is :"+crosspoint);

		genecounter = 0;

		boolean doneA = false;
		boolean doneB = false;
		boolean done = false;
		double v1 = 0.0;
		double v2 = 0.0;
		double vmax = 0.0;
		double cellA = 0.0;
		double cellB = 0.0;

		j1 = 0;
		j2 = 0;
		j = 0;

		//
		// compute what is the hight innovation
		//

		double last_innovB = ((Gene) genomeB.get(stopB - 1))
				.getInnovationNumber();
		double cross_innov = 0;

		while (!done) {

			doneA = false;
			doneB = false;
			skip = false;
			avgene.setEnabled(true); // Default to true

			if (j1 < stopA) {
				geneA = (Gene) genomeA.get(j1);
				v1 = geneA.getInnovationNumber();
				doneA = true;
			}
			if (j2 < stopB) {
				geneB = (Gene) genomeB.get(j2);
				v2 = geneB.getInnovationNumber();
				doneB = true;
			}

			if (doneA && doneB) {
				//
				if (v1 < v2) {
					cellA = v1;
					cellB = 0.0;
					j1++;
				} else if (v1 == v2) {
					cellA = v1;
					cellB = v1;
					j1++;
					j2++;
				} else {
					cellA = 0.0;
					cellB = v2;
					j2++;
				}
			}

			else {
				if (doneA && !doneB) {
					cellA = v1;
					cellB = 0.0;
					j1++;
				} else if (!doneA && doneB) {
					cellA = 0.0;
					cellB = v2;
					j2++;
				} else
					done = true;
			}

			if (!done) {

				// -------------------------------------------------------------------------------
				// innovA = innovB
				// -------------------------------------------------------------------------------

				if (cellA == cellB) {
					if (genecounter < crosspoint) {
						chosengene = geneA;
						genecounter++;
					} else if (genecounter == crosspoint) {
						if (RandomUtils.randomDouble() > 0.5)
							avgene.getLink().setTrait(geneA.getLink().getTrait());
						else
							avgene.getLink().setTrait(geneB.getLink().getTrait());

						// WEIGHTS AVERAGED HERE
						avgene.getLink().setWeight((geneA.getLink().getWeight() + geneB
								.getLink().getWeight()) / 2.0);

						if (RandomUtils.randomDouble() > 0.5)
							avgene.getLink().setInputNode(geneA.getLink().getInputNode());
						else
							avgene.getLink().setInputNode(geneB.getLink().getInputNode());

						if (RandomUtils.randomDouble() > 0.5)
							avgene.getLink().setOutputNode(geneA.getLink().getOutputNode());
						else
							avgene.getLink().setOutputNode(geneB.getLink().getOutputNode());

						if (RandomUtils.randomDouble() > 0.5)
							avgene.getLink().setRecurrent(geneA.getLink().isRecurrent());
						else
							avgene.getLink().setRecurrent(geneB.getLink().isRecurrent());

						avgene.setInnovationNumber(geneA.getInnovationNumber());
						avgene
								.setMutationNumber((geneA.getMutationNumber() + geneB
										.getMutationNumber()) / 2.0);

						// If one is disabled, the corresponding gene in the
						// offspring
						// will likely be disabled

						if ((geneA.isEnabled() == false)
								|| (geneB.isEnabled() == false))
							avgene.setEnabled(false);

						chosengene = avgene;
						genecounter++;
						cross_innov = cellA;
					} else if (genecounter > crosspoint) {
						chosengene = geneB;
						genecounter++;
					}
				}

				// -------------------------------------------------------------------------------
				// innovA < innovB
				// -------------------------------------------------------------------------------

				else if (cellA != 0 && cellB == 0) {
					if (genecounter < crosspoint) {
						chosengene = geneA; // make geneA
						genecounter++;
					} else if (genecounter == crosspoint) {
						chosengene = geneA;
						genecounter++;
						cross_innov = cellA;
					} else if (genecounter > crosspoint) {
						if (cross_innov > last_innovB) {
							chosengene = geneA;
							genecounter++;
						} else {
							skip = true;
						}
					}
				}

				// -------------------------------------------------------------------------------
				// innovA > innovB
				// -------------------------------------------------------------------------------

				else {
					if (cellA == 0 && cellB != 0) {
						if (genecounter < crosspoint) {
							skip = true; // skip geneB
						} else if (genecounter == crosspoint) {
							skip = true; // skip an illogic case
						} else if (genecounter > crosspoint) {
							if (cross_innov > last_innovB) {
								chosengene = geneA; // make geneA
								genecounter++;
							} else {
								chosengene = geneB; // make geneB : this is a
													// pure case o single
													// crossing
								genecounter++;
							}
						}

					}
				}

				itr_newgenes = newgenes.iterator();

				while (itr_newgenes.hasNext()) {
					_curgene2 = ((Gene) itr_newgenes.next());

					if (_curgene2.getLink().getInputNode().getId() == chosengene
							.getLink().getInputNode().getId()
							&& _curgene2.getLink().getOutputNode().getId() == chosengene
									.getLink().getOutputNode().getId()
							&& _curgene2.getLink().isRecurrent() == chosengene
									.getLink().isRecurrent()) {
						skip = true;
						break;
					}

					if (_curgene2.getLink().getInputNode().getId() == chosengene
							.getLink().getOutputNode().getId()
							&& _curgene2.getLink().getOutputNode().getId() == chosengene
									.getLink().getInputNode().getId()
							&& !_curgene2.getLink().isRecurrent()
							&& !chosengene.getLink().isRecurrent()) {
						skip = true;
						break;
					}

				} // and else for control of position in gennomeA/B

				if (!skip) {
					// Now add the chosengene to the baby
					// First, get the trait pointer
					int first_traitnum = ((Trait) traits.get(0)).getId();

					if (chosengene.getLink().getTrait() == null)
						traitnum = first_traitnum;
					else
						traitnum = chosengene.getLink().getTrait().getId()
								- first_traitnum;

					// Next check for the nodes, add them if not in the baby
					// Genome already

					inode = chosengene.getLink().getInputNode();
					onode = chosengene.getLink().getOutputNode();

					//
					// Check for inode, onode in the newnodes list
					//
					boolean found;
					if (inode.getId() < onode.getId()) {
						//
						// search the inode
						// 
						found = false;
						for (int ix = 0; ix < newnodes.size(); ix++) {
							curnode = (NNode) newnodes.get(ix);
							if (curnode.getId() == inode.getId()) {
								found = true;
								break;
							}
						}
						// if exist , point to exitsting version
						if (found)
							new_inode = curnode;
						// else create the inode
						else {
							if (inode.getTrait() == null)
								nodetraitnum = 0;
							else
								nodetraitnum = inode.getTrait().getId()
										- first_traitnum;
							newtrait = (Trait) newtraits.get(nodetraitnum);
							new_inode = new NNode(inode, newtrait);
							// insert in newnodes list
							nodeInsert(newnodes, new_inode);
						}

						//
						// search the onode
						// 
						found = false;
						for (int ix = 0; ix < newnodes.size(); ix++) {
							curnode = (NNode) newnodes.get(ix);
							if (curnode.getId() == onode.getId()) {
								found = true;
								break;
							}
						}
						// if exist , point to exitsting version
						if (found)
							new_onode = curnode;
						// else create the onode
						else {
							if (onode.getTrait() == null)
								nodetraitnum = 0;
							else
								nodetraitnum = onode.getTrait().getId()
										- first_traitnum;
							newtrait = (Trait) newtraits.get(nodetraitnum);
							new_onode = new NNode(onode, newtrait);
							// insert in newnodes list
							nodeInsert(newnodes, new_onode);
						}
					} // end block : inode.node_id < onode.node_id

					else {
						//
						// search the onode
						// 
						found = false;
						for (int ix = 0; ix < newnodes.size(); ix++) {
							curnode = (NNode) newnodes.get(ix);
							if (curnode.getId() == onode.getId()) {
								found = true;
								break;
							}
						}
						// if exist , point to exitsting version
						if (found)
							new_onode = curnode;
						// else create the onode
						else {
							if (onode.getTrait() == null)
								nodetraitnum = 0;
							else
								nodetraitnum = onode.getTrait().getId()
										- first_traitnum;
							newtrait = (Trait) newtraits.get(nodetraitnum);
							new_onode = new NNode(onode, newtrait);
							// insert in newnodes list
							nodeInsert(newnodes, new_onode);
						}
						//
						// search the inode
						// 
						found = false;
						for (int ix = 0; ix < newnodes.size(); ix++) {
							curnode = (NNode) newnodes.get(ix);
							if (curnode.getId() == inode.getId()) {
								found = true;
								break;
							}

						}

						// if exist , point to exitsting version
						if (found)
							new_inode = curnode;
						// else create the inode
						else {
							if (inode.getTrait() == null)
								nodetraitnum = 0;
							else
								nodetraitnum = inode.getTrait().getId()
										- first_traitnum;

							newtrait = (Trait) newtraits.get(nodetraitnum);
							new_inode = new NNode(inode, newtrait);

							// insert in newnodes list
							nodeInsert(newnodes, new_inode);
						}
					}

					// Add the Gene
					newtrait = (Trait) newtraits.get(traitnum);
					newgene = new Gene(chosengene, newtrait, new_inode,
							new_onode);
					newgenes.add(newgene);

				} // end of block gene creation if !skip

			}
			j++;

		}

		new_genome = new Genome(id, newtraits, newnodes, newgenes);
		//
		// search the existence of output node
		// if no dump
		// 

		return new_genome;

	}

	public void mutateGeneReenable() {
		for (Gene gene : genes) {
			if (!gene.isEnabled()) {
				gene.setEnabled(true);
				break;
			}
		}
	}

	/**
	 * This chooses a random gene, extracts the link from it, and repoints the
	 * link to a random trait
	 */
	public void mutateLinkTrait(int repeats) {
		int traitnum;
		int genenum;
		int count;
		int loop;
		Gene _gene = null;
		Trait _trait = null;

		for (loop = 1; loop <= repeats; loop++) {

			// Choose a random traitnum
			traitnum = RandomUtils.randomInt(0, traits.size() - 1);
			// Choose a random linknum
			genenum = RandomUtils.randomInt(0, genes.size() - 1);
			// set the link to point to the new trait
			_gene = (Gene) genes.get(genenum);
			_trait = (Trait) traits.get(traitnum);
			_gene.getLink().setTrait(_trait);

			// TRACK INNOVATION- future use
			// (*thegene)->mutation_num+=randposneg()*randfloat()*linktrait_mut_sig;

		}

	}

	/**
	 * This chooses a random node and repoints the node to a random trait
	 */
	public void mutateNodeTrait(int repeats) {
		int traitnum;
		int nodenum;
		int count;
		int loop;
		NNode _node = null;
		Trait _trait = null;

		for (loop = 1; loop <= repeats; loop++) {

			// Choose a random traitnum
			traitnum = RandomUtils.randomInt(0, (traits.size()) - 1);
			// Choose a random nodenum
			nodenum = RandomUtils.randomInt(0, nodes.size() - 1);
			// set the link to point to the new trait
			_node = (NNode) nodes.get(nodenum);
			_trait = (Trait) traits.get(traitnum);
			_node.setTrait((Trait) traits.get(traitnum));

			// TRACK INNOVATION! - possible future use
			// for any gene involving the mutated node, perturb that gene's
			// mutation number
			// for(thegene=genes.begin();thegene!=genes.end();++thegene) {
			// if (((((*thegene)->lnk)->in_node)==(*thenode))
			// ||
			// ((((*thegene)->lnk)->out_node)==(*thenode)))
			// (*thegene)->mutation_num+=randposneg()*randfloat()*nodetrait_mut_sig;
			// }
		}

	}

	/**
	 * Insert the method's description here. Creation date: (24/01/2002 9.03.36)
	 */
	public void mutateRandomTrait() {
		int traitnum;

		// Choose a random traitnum
		traitnum = RandomUtils.randomInt(0, (traits.size()) - 1);
		// Retrieve the trait and mutate it
		Trait _trait = (Trait) traits.get(traitnum);
		_trait.mutate();

		// TRACK INNOVATION? (future possibility)
	}

	/**
	 * Insert the method's description here. Creation date: (24/01/2002 9.03.36)
	 */
	//
	// Toggle genes from enable on to enable off or
	// vice versa. Do it times times.
	//
	public void mutateToggleEnable(int repeats) {
		int genenum;
		int count;
		int genecount;
		Gene _gene = null;
		Gene _jgene = null;

		int len_gene = genes.size();
		boolean done = false;

		for (count = 1; count <= repeats; count++) {

			// Choose a random genenum
			genenum = RandomUtils.randomInt(0, genes.size() - 1);
			// find the gene
			_gene = (Gene) genes.get(genenum);
			// Toggle the enable on this gene

			if (_gene.isEnabled()) {
				// We need to make sure that another gene connects out of the
				// in-node
				// Because if not a section of network will break off and become
				// isolated
				done = false;
				for (int j = 0; j < len_gene; j++) {
					_jgene = (Gene) genes.get(j);
					if ((_gene.getLink().getInputNode() == _jgene.getLink().getInputNode())
							&& _jgene.isEnabled()
							&& (_jgene.getInnovationNumber() != _gene
									.getInnovationNumber())) {
						done = true;
						break;
					}
				}
				// Disable the gene if it's safe to do so
				if (done)
					_gene.setEnabled(false);

			} else
				_gene.setEnabled(true);
		}

	}

	public void nodeInsert(ArrayList<NNode> nlist, NNode n) {
		int j;
		int id = n.getId();
		int sz = nlist.size();

		for (j = 0; j < sz; j++) {
			if (((NNode) nlist.get(j)).getId() >= id)
				break;
		}
		nlist.add(j, n);

	}

	public boolean mutateAddLink(Population population, int attempts) {
		boolean done = false;
		boolean do_recur = false;
		boolean loop_recur = false;
		boolean recur_flag = false;
		boolean found = false;
		boolean bypass = false;
		boolean recurflag = false;

		int first_nonsensor;
		int trycount = 0;

		int thresh = (nodes.size()) * (nodes.size());
		int count = 0;
		int nodenum1;
		int nodenum2;
		long lcount;
		int traitnum;
		double new_weight;

		NNode thenode1 = null;
		NNode thenode2 = null;
		Gene new_gene = null;
		Gene _gene = null;

		Iterator itr_gene = null;
		Iterator itr_node = null;
		Iterator<IInnovation> itr_innovation = null;

		// Make attempts to find an unconnected pair
		trycount = 0;

		// Decide whether to make this recurrent
		if (RandomUtils.randomDouble() < Neat.recur_only_prob)
			do_recur = true;
		else
			do_recur = false;

		// Find the first non-sensor so that the to-node won't look at sensors
		// as
		// possible destinations

		itr_node = nodes.iterator();
		first_nonsensor = 0;

		while (itr_node.hasNext()) {
			thenode1 = ((NNode) itr_node.next());
			if (thenode1.type != NeatConstant.SENSOR)
				break;
			first_nonsensor++;

		}
		found = false;
		while (trycount < attempts) {
			//
			// recurrency case .........
			//

			if (do_recur) {
				//
				// at this point :
				// 50% of prob to decide a loop recurrency( node X to node X)
				// 50% a normal recurrency ( node X to node Y)
				if (RandomUtils.randomDouble() > 0.5)
					loop_recur = true;
				else
					loop_recur = false;

				if (loop_recur) {
					nodenum1 = RandomUtils.randomInt(first_nonsensor, nodes
							.size() - 1);
					nodenum2 = nodenum1;
				} else {
					nodenum1 = RandomUtils.randomInt(0, nodes.size() - 1);
					nodenum2 = RandomUtils.randomInt(first_nonsensor, nodes
							.size() - 1);
				}

			}
			//
			// no recurrency case .........
			//
			else {
				nodenum1 = RandomUtils.randomInt(0, nodes.size() - 1);
				nodenum2 = RandomUtils.randomInt(first_nonsensor, nodes.size() - 1);

			}

			//
			// now point to object's nodes
			//
			thenode1 = (NNode) nodes.get(nodenum1);
			thenode2 = (NNode) nodes.get(nodenum2);

			//
			// verify if the possible new gene already EXIST
			//
			bypass = false;
			for (int j = 0; j < genes.size(); j++) {
				_gene = (Gene) genes.get(j);
				if (thenode2.type == NeatConstant.SENSOR) {
					bypass = true;
					break;
				}
				if (_gene.getLink().getInputNode() == thenode1
						&& _gene.getLink().getOutputNode() == thenode2
						&& _gene.getLink().isRecurrent() && do_recur) {
					bypass = true;
					break;
				}

				if (_gene.getLink().getInputNode() == thenode1
						&& _gene.getLink().getOutputNode() == thenode2
						&& !_gene.getLink().isRecurrent() && !do_recur) {
					bypass = true;
					break;
				}

			}

			if (!bypass) {

				phenotype.status = 0;
				recurflag = phenotype.has_a_path(thenode1.analogue,
						thenode2.analogue, 0, thresh);

				if (phenotype.status == 8) {
					System.out
							.println("\n  network.mutate_add_link : LOOP DETECTED DURING A RECURRENCY CHECK");
					return false;
				}

				if ((!recurflag && do_recur) || (recurflag && !do_recur))
					trycount++;
				else {
					trycount = attempts;
					found = true;
				}

			} // end block bypass

			//
			// if bypass is true, this gene is not good
			// and skip to next cycle
			//
			else
				trycount++;

		} // end block trycount

		if (found) {

			// Check to see if this innovation already occured in the population
			itr_innovation = population.innovations.iterator();

			done = false;
			while (!done) {

				if (!itr_innovation.hasNext()) {

					// If the phenotype does not exist, exit on false,print
					// error
					// Note: This should never happen- if it does there is a bug
					if (phenotype == null) {
						System.out
								.print("ERROR: Attempt to add link to genome with no phenotype");
						return false;
					}

					// Choose a random trait
					traitnum = RandomUtils.randomInt(0, traits.size() - 1);

					// Choose the new weight
					// newweight=(gaussrand())/1.5; //Could use a gaussian
					new_weight = RandomUtils.randomBinomial() * RandomUtils.randomDouble() * 10.0;

					// read from population current innovation value

					// read curr innovation with postincrement
					double curr_innov = population.getCurr_innov_num_and_increment();
					// Create the new gene
					new_gene = new Gene((Trait) traits.get(traitnum),
							new_weight, thenode1, thenode2, do_recur,
							curr_innov, new_weight);
					// Add the innovation
					population.innovations.add(new Innovation(thenode1.getId(), thenode2.getId(), curr_innov, new_weight, traitnum));
					done = true;

				}

				// OTHERWISE, match the innovation in the innovs list
				else {
					IInnovation _innov = itr_innovation.next();
					if ((_innov.getInnovationType() == NeatConstant.NEWLINK)
							&& (_innov.getInputNodeId() == thenode1.getId())
							&& (_innov.getOutputNodeId() == thenode2.getId())
							&& (_innov.isRecurrent() == do_recur)) {

						new_gene = new Gene((Trait) traits.get(_innov.getNewTraitId()), _innov.getNewWeight(), thenode1, thenode2, do_recur, _innov.getInnovationNumber1(), 0);
						done = true;
					}
				}
			}

			genes.add(new_gene);
			return true;
		}

		return false;

	}

	public boolean mutateAddNode(Population population) {

		Iterator itr_gene;
		Gene _gene = null;

		Link thelink = null;
		double oldweight = 0;

		Gene newgene1 = null;
		Gene newgene2 = null;
		NNode in_node = null;
		NNode out_node = null;
		NNode new_node = null;
		Iterator itr_innovation;
		Trait traitptr = null;

		int j;
		int genenum = 0;
		int trycount = 0;

		boolean found = false;
		boolean bypass = false;
		boolean step1 = true;
		boolean step2 = false;
		double gene_innov1;
		double gene_innov2;

		if (genes.size() < 15) {

			step2 = false;
			for (j = 0; j < genes.size(); j++) {
				_gene = (Gene) genes.get(j);
				if (_gene.isEnabled()
						&& (_gene.getLink().getInputNode().gen_node_label != NodeLabel.BIAS))
					break;
			}

			for (; j < genes.size(); j++) {
				_gene = (Gene) genes.get(j);
				if ((RandomUtils.randomDouble() >= 0.3)
						&& (_gene.getLink().getInputNode().gen_node_label != NodeLabel.BIAS)) {
					step2 = true;
					break;
				}
			}

			if ((step2) && (_gene.isEnabled())) {
				found = true;

			}

		} else {
			while ((trycount < 20) && (!found)) {
				// Pure random splittingNeatRoutine.randint
				genenum = RandomUtils.randomInt(0, genes.size() - 1);
				_gene = (Gene) genes.get(genenum);
				if (_gene.isEnabled()
						&& (_gene.getLink().getInputNode().gen_node_label != NodeLabel.BIAS))
					found = true;
				++trycount;

			}
		}

		if (!found)
			return false;

		_gene.setEnabled(false);

		// Extract the link
		thelink = _gene.getLink();
		// Extract the weight;
		oldweight = thelink.getWeight();
		// Get the old link's trait
		traitptr = thelink.getTrait();

		// Extract the nodes
		in_node = thelink.getInputNode();
		out_node = thelink.getOutputNode();

		boolean done = false;
		itr_innovation = population.innovations.iterator();

		while (!done) {
			// Check to see if this innovation already occured in the population
			if (!itr_innovation.hasNext()) {

				// The innovation is totally novel
				// Create the new Genes
				// Create the new NNode
				// By convention, it will point to the first trait
				// get the current node id with postincrement

				int curnode_id = population.getCur_node_id_and_increment();

				// pass this current nodeid to newnode and create the new node
				new_node = new NNode(NeatConstant.NEURON, curnode_id, NodeLabel.HIDDEN);
				new_node.setTrait((Trait) traits.get(0));

				// get the current gene inovation with post increment
				gene_innov1 = population.getCurr_innov_num_and_increment();

				// create gene with the current gene inovation
				newgene1 = new Gene(traitptr, 1.0, in_node, new_node,
						thelink.isRecurrent(), gene_innov1, 0);

				// re-read the current innovation with increment
				gene_innov2 = population.getCurr_innov_num_and_increment();

				// create the second gene with this innovation incremented
				newgene2 = new Gene(traitptr, oldweight, new_node, out_node,
						false, gene_innov2, 0);

				population.innovations.add(new Innovation(in_node.getId(), out_node
						.getId(), gene_innov1, gene_innov2, new_node.getId(),
						_gene.getInnovationNumber()));
				done = true;
			}
			// end for new innovation case
			else {
				Innovation _innov = ((Innovation) itr_innovation.next());

				if ((_innov.innovationType == NeatConstant.NEWNODE)
						&& (_innov.inputNodeId == in_node.getId())
						&& (_innov.outputNodeId == out_node.getId())
						&& (_innov.oldInnovationNumber == _gene.getInnovationNumber())) {
					// Create the new Genes
					// pass this current nodeid to newnode
					new_node = new NNode(NeatConstant.NEURON,
							_innov.newNodeId, NodeLabel.HIDDEN);
					new_node.setTrait((Trait) traits.get(0));

					newgene1 = new Gene(traitptr, 1.0, in_node, new_node,
							thelink.isRecurrent(), _innov.innovationNumber1, 0);
					newgene2 = new Gene(traitptr, oldweight, new_node,
							out_node, false, _innov.innovationNumber2, 0);
					done = true;

				}
			}

		}

		// Now add the new NNode and new Genes to the Genome

		genes.add(newgene1);
		genes.add(newgene2);
		nodeInsert(nodes, new_node);

		return true;

	}

	/**
	 * 
	 * Creation of a new random genome with : new_id = numerical identification
	 * of genome i = number of input nodes o = number of output nodes n = number
	 * of hidden nodes nmax = number max of node this number must be >= (i + n +
	 * o) r = the network can have a nodes recurrent ? linkprob = probability of
	 * a link from nodes ( must be in interval ]0,1[);
	 */
	public Genome(int new_id, int i, int o, int n, int nmax, boolean r,
			double linkprob) {
		int totalnodes = 0;
		int matrixdim = 0;
		int maxnode = 0;
		int first_output = 0;
		int count = 0;
		int ccount = 0;
		int innov_number = 0;
		int col = 0;
		int row = 0;
		int fnd = 0;
		int pointer = 0;
		int gene_number = 0;

		boolean flag_recurrent = false;
		boolean create_gene = false;

		double new_weight = 0.0;

		Trait newtrait = null;
		NNode newnode = null;
		NNode in_node = null;
		NNode out_node = null;
		Gene newgene = null;

		notes = null;

		Iterator itr_node;

		//
		// i i i n n n n n n n n n n n n n n n n . . . . . . . . o o o o
		// | | ^ |
		// |<----------- maxnode ------------->| | |
		// | | |
		// |<-----------------------total nodes -----------------|---->|
		// |
		// |
		// first output ----------------------------------------+
		//
		//
		totalnodes = i + o + nmax;

		traits = new ArrayList<Trait>(Neat.num_trait_params);
		nodes = new ArrayList<NNode>(totalnodes);
		genes = new ArrayList<Gene>(totalnodes);

		matrixdim = totalnodes * totalnodes;

		boolean[] cm = new boolean[matrixdim]; // Dimension the connection
												// matrix
		boolean[] cmp;

		maxnode = i + n;
		first_output = totalnodes - o + 1;

		// Assign the id
		setId(new_id);

		// Create a dummy trait (this is for future expansion of the system)

		newtrait = new Trait(1, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		traits.add(newtrait);

		// Build the input nodes
		for (count = 1; count <= i; count++) {
			if (count < i)
				newnode = new NNode(NeatConstant.SENSOR, count,
						NodeLabel.INPUT);
			else
				newnode = new NNode(NeatConstant.SENSOR, count,
						NodeLabel.BIAS);

			newnode.setTrait(newtrait);
			// Add the node to the list of nodes
			nodes.add(newnode);
		}

		// Build the hidden nodes
		for (count = i + 1; count <= i + n; count++) {
			newnode = new NNode(NeatConstant.NEURON, count, NodeLabel.HIDDEN);
			newnode.setTrait(newtrait);

			// Add the node to the list of nodes
			nodes.add(newnode);
		}

		// Build the output nodes
		for (count = first_output; count <= totalnodes; count++) {
			newnode = new NNode(NeatConstant.NEURON, count, NodeLabel.OUTPUT);
			newnode.setTrait(newtrait);

			// Add the node to the list of nodes
			nodes.add(newnode);
		}

		boolean done = false;
		boolean rc1 = false;
		boolean rc2 = false;
		boolean rc3 = false;

		int min_required = i * o;
		double forced_probability = 0.5;
		int abort = 0;

		while (!done) {

			abort++;
			if (abort >= 20) {
				// if (abort == 10)
				// System.out.print("\n ALERT  force new probability from 0.5 to 1 step .01");
				linkprob = forced_probability;
				forced_probability += .01;
			}

			if (abort >= 700) {
				System.out
						.print("\n SEVERE ERROR in genome random creation costructor : genome has not created");
				System.exit(12);
			}

			//
			// creation of connections matrix
			// Step through the connection matrix, randomly assigning bits
			//

			cmp = cm;
			ccount = 0;
			for (count = 0; count < matrixdim; count++) {
				if (RandomUtils.randomDouble() < linkprob) {
					ccount++;
					cmp[count] = true;
				} else
					cmp[count] = false;
			}

			// Connect the nodes

			innov_number = 0; // counter for labelling the innov_num of genes
			gene_number = 0; // counter gene created

			// Step through the connection matrix, creating connection genes

			cmp = cm;

			for (col = 1; col <= totalnodes; col++) {
				for (row = 1; row <= totalnodes; row++) {

					if ((cmp[innov_number] && (col > i))
							&& ((col <= maxnode) || (col >= first_output))
							&& ((row <= maxnode) || (row >= first_output))) {
						// If it isn't recurrent, create the connection no
						// matter what

						create_gene = true;
						if (col > row)
							flag_recurrent = false;
						else {
							if (!r)
								create_gene = false;
							flag_recurrent = true;
						}

						if (create_gene) {
							itr_node = nodes.iterator(); // Retrieve the in_node
															// , out_node
							fnd = 0;
							while (itr_node.hasNext() && (fnd < 2)) {
								NNode _node = ((NNode) itr_node.next());
								if (_node.getId() == row) {
									fnd++;
									in_node = _node;
								}
								if (_node.getId() == col) {
									fnd++;
									out_node = _node;
								}
							}
							// Create the gene + link
							new_weight = RandomUtils.randomBinomial() * RandomUtils.randomDouble();
							newgene = new Gene(newtrait, new_weight, in_node,
									out_node, flag_recurrent, innov_number,
									new_weight);
							// Add the gene to the genome
							genes.add(newgene);
						}
					} // end condition for a correct link in genome
					innov_number++;
				}
			}

			rc1 = verify();

			// System.out.print("\n      -> +rc1 = "+rc1);

			if (rc1) {
				Network net = this.genesis(getId());
				rc2 = net.is_minimal();

				// System.out.print("\n         -> +rc2 = "+rc2);

				if (rc2) {
					int lx = net.max_depth();
					int dx = net.is_stabilized(lx);

					// System.out.print("\n        lx = " + lx);
					// System.out.print(", dx = " + dx);

					if (((dx == lx) && (!r)) || ((lx > 0) && (r) && (dx == 0)))
						done = true;

				}
				net.genotype = null;
				this.phenotype = null;
			}
			if (!done)
				genes.clear();
			// else
			// System.out.print("\n * CREATION Genome #"+genome_id+" okay");
		}

	}

	public void print_to_file(IOseq xFile) {
		//
		// write to file genome in native format (for re-read)
		//

		String riga = "genomestart  " + getId();
		xFile.IOseqWrite(riga);

		Iterator itr_trait = traits.iterator();
		itr_trait = traits.iterator();

		while (itr_trait.hasNext()) {
			Trait _trait = ((Trait) itr_trait.next());
			_trait.print_to_file(xFile);
		}

		Iterator itr_node = nodes.iterator();
		itr_node = nodes.iterator();

		while (itr_node.hasNext()) {
			NNode _node = ((NNode) itr_node.next());
			_node.print_to_file(xFile);
		}

		Iterator itr_gene = genes.iterator();
		itr_gene = genes.iterator();

		while (itr_gene.hasNext()) {
			Gene _gene = ((Gene) itr_gene.next());
			_gene.print_to_file(xFile);
		}

		riga = "genomeend " + getId();
		xFile.IOseqWrite(riga);

	}

	/**
   * 
   * 
   */

	public void View_mate_singlepoint(Genome g, int genomeid) {

		String mask4 = " 0000";
		DecimalFormat fmt4 = new DecimalFormat(mask4);

		Genome new_genome = null;
		int stopA = 0;
		int stopB = 0;
		int j;
		int j1;
		int j2;

		int size1 = genes.size();
		int size2 = g.genes.size();

		int crosspoint = 0;

		ArrayList<Gene> genomeA;
		ArrayList<Gene> genomeB;
		int genecounter = 0; // Ready to count to crosspoint

		if (size1 < size2) {
			stopA = size1;
			stopB = size2;
			genomeA = genes;
			genomeB = g.genes;
		} else {
			stopA = size2;
			stopB = size1;
			genomeA = g.genes;
			genomeB = genes;
		}

		double v3[][] = new double[size2 * 2][2];
		double vr[] = new double[size2 * 2];

		for (crosspoint = 0; crosspoint < stopA; crosspoint++)

		{

			genecounter = 0;

			boolean doneA = false;
			boolean doneB = false;
			boolean done = false;
			double v1 = 0.0;
			double v2 = 0.0;
			double vmax = 0.0;
			j1 = 0;
			j2 = 0;
			j = 0;

			double cross_innov = 0;
			//
			// compute what is the hight innovation
			//	

			double last_innovB = ((Gene) genomeB.get(stopB - 1))
					.getInnovationNumber();

			while (!done) {

				doneA = false;
				doneB = false;

				if (j1 < stopA) {
					v1 = ((Gene) genomeA.get(j1)).getInnovationNumber();
					doneA = true;
				}
				if (j2 < stopB) {
					v2 = ((Gene) genomeB.get(j2)).getInnovationNumber();
					doneB = true;
				}

				if (doneA && doneB) {
					//
					if (v1 < v2) {
						v3[j][0] = v1;
						v3[j][1] = 0.0;
						j1++;
					} else if (v1 == v2) {
						v3[j][0] = v1;
						v3[j][1] = v1;
						j1++;
						j2++;
					} else {
						v3[j][0] = 0.0;
						v3[j][1] = v2;
						j2++;
					}
				}

				else {
					if (doneA && !doneB) {
						v3[j][0] = v1;
						v3[j][1] = 0.0;
						j1++;
					} else if (!doneA && doneB) {
						v3[j][0] = 0.0;
						v3[j][1] = v2;
						j2++;
					} else
						done = true;
				}

				if (!done) {

					// -------------------------------------------------------------------------------
					// innovA = innovB
					// -------------------------------------------------------------------------------

					if (v3[j][0] == v3[j][1]) {
						if (genecounter < crosspoint) {
							vr[j] = 1;
							genecounter++;
						} else if (genecounter == crosspoint) {
							vr[j] = 3;
							genecounter++;
							cross_innov = v3[j][0];
						} else if (genecounter > crosspoint) {
							vr[j] = 2;
							genecounter++;
						}
					}

					// -------------------------------------------------------------------------------
					// innovA < innovB
					// -------------------------------------------------------------------------------

					else if (v3[j][0] != 0 && v3[j][1] == 0) {
						if (genecounter < crosspoint) {
							vr[j] = 1; // v3[j][0];
							genecounter++;
						} else if (genecounter == crosspoint) {
							vr[j] = 1; // v3[j][1])
							genecounter++;
							cross_innov = v3[j][0];
						} else if (genecounter > crosspoint) {

							if (cross_innov > last_innovB) {
								vr[j] = 1;
								genecounter++;
							}
						}
					}

					// -------------------------------------------------------------------------------
					// innovA > innovB
					// -------------------------------------------------------------------------------

					else if (v3[j][0] == 0 && v3[j][1] != 0) {
						if (genecounter < crosspoint) {
							vr[j] = 0; // skip v3[j][0];
						} else if (genecounter == crosspoint) {
							vr[j] = 0; // skip
						}

						else if (genecounter > crosspoint) {
							if (cross_innov > last_innovB) {
								vr[j] = 1; // v3[j][1];
								genecounter++;
							} else {
								vr[j] = 2;
								genecounter++;
							}
						}

					}
				}
				j++;

			}

			int len_max = --j;

			//
			// only for debug : view innov's genomeA,B
			//	
			System.out.print("\n\n CROSSING SINGLE at index " + crosspoint);
			System.out.print("\n -- index -- ");
			int column = 0;
			for (j2 = 0; j2 < len_max; j2++) {
				if (v3[j2][0] > 0.0)
					System.out.print(fmt4.format((long) column++));
				else
					System.out.print("     ");
			}
			System.out.print("\n ----------- ");
			for (j2 = 0; j2 < len_max; j2++)
				System.out.print("-----");
			for (j1 = 0; j1 < 2; j1++) {
				System.out.print("\n Genome  [" + j1 + "] ");
				for (j2 = 0; j2 < len_max; j2++)
					System.out.print(fmt4.format((long) v3[j2][j1]));
			}
			System.out.print("\n newgene [X] ");
			for (j2 = 0; j2 < len_max; j2++) {
				if (vr[j2] == 1)
					System.out.print("  AA ");
				else if (vr[j2] == 2)
					System.out.print("  BB ");
				else if (vr[j2] == 3)
					System.out.print("  XX ");
				else if (vr[j2] == 4)
					System.out.print("  MM ");
				else if (vr[j2] == 0)
					System.out.print("  -- ");
			}
			System.out.print("\n");
		}

	}

	public void print_to_filename(String xNameFile, String descr) {
		//
		// write to file genome in native format (for re-read)
		//
		IOseq xFile;

		xFile = new IOseq(xNameFile);
		xFile.IOseqOpenW(false);

		try {

			String riga = descr;
			xFile.IOseqWrite(riga);

			print_to_file(xFile);

		} catch (Throwable e) {
			System.err.println(e);
		}

		xFile.IOseqCloseW();

	}

	public void setId(int id) {
		this.id = id;
	}

	public int getId() {
		return id;
	}
	
	public String toString() {

		StringBuilder s = new StringBuilder();
		
		s.append("GENOME START   id=" + getId());
		s.append("\n  genes are :" + genes.size());
		s.append("\n  nodes are :" + nodes.size());
		s.append("\n  trait are :" + traits.size());

		for (NNode _node : nodes) {
			if (_node.getGen_node_label() == NodeLabel.INPUT)
				s.append("\n Input ");
			if (_node.getGen_node_label() == NodeLabel.OUTPUT)
				s.append("\n Output");
			if (_node.getGen_node_label() == NodeLabel.HIDDEN)
				s.append("\n Hidden");
			if (_node.getGen_node_label() == NodeLabel.BIAS)
				s.append("\n Bias  ");
			s.append(_node.toString());
		}

		for (Gene _gene : genes) {
			s.append(_gene.toString());
		}

		s.append("\n Traits:\n");

		for (Trait _trait : traits) {
			s.append(_trait.toString());
		}
		
		return s.toString();
	}
}